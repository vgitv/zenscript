#!/bin/bash
set -euo pipefail

# Take a quizz based on a CSV file. First field is the question, second field
# the answer.

data_file="$1"
sep="${2:-,}"

export NC="\033[0m"

export blue="\033[1;34m"
export green="\033[1;32m"
export orange="\033[1;33m"
export red="\033[1;31m"


function log {
    local args=()
    while [[ $1 =~ ^- ]]; do
        args+=("$1")
        shift
    done
    echo "${args[@]}" -e "${!1:?}${2}${NC}"
}


MAX_WIDTH="$(awk -F "$sep" '{ print length($1) }' "$data_file" | sort -n | tail -n 1)"
DELIM=' -> '

function ask {
    printf "%-${MAX_WIDTH}s" "$1"
    printf '%s' "$DELIM"
}

tmp="$(mktemp)"
shuf "$data_file" > "$tmp"

SECONDS=0

wrong_cpt=0
right_cpt=0

wrong_items=()

# -u arg is require here because of the nested read
while IFS= read -u 3 -r line; do
    question="$(echo "$line" | cut -d "$sep" -f 1)"
    answer="$(echo "$line" | cut -d "$sep" -f 2)"
    ask "${question}"
    IFS=" " read -r input
    delim_width="${#DELIM}"
    input_width="${#input}"
    width="$((MAX_WIDTH+delim_width+input_width))"
    if [[ ${input,,} != "${answer,,}" ]]; then
        wrong_cpt=$((wrong_cpt+1))
        wrong_items+=("$(printf "%-${MAX_WIDTH}s" "$question")${DELIM}${answer}")
    else
        log green "\033[1A\033[${width}C  OK"
        right_cpt=$((right_cpt+1))
    fi
    while [[ ${input,,} != "${answer,,}" ]]; do
        if [[ -z "$input" ]]; then
            log -n orange "\033[1A\033[$((MAX_WIDTH+delim_width))C${answer}"
            echo -n " (press enter to continue)"
            read -r
            break
        fi
        log red "\033[1A\033[${width}C  Incorrect, try again! (Leave empty to get the solution)"
        ask "$question"
        IFS=" " read -r input
    done
done 3< "$tmp"

echo

if [[ $wrong_cpt -ne 0 ]]; then
    log orange "${wrong_cpt} wrong answer(s):"
    for elt in "${wrong_items[@]}"; do
        log orange "  $elt"
    done
    echo
fi

if [[ $right_cpt -ne 0 ]]; then
    log green "${right_cpt} right answer(s)"
fi

log -n blue "\nWell done!\nTotal time: "
if [[ $SECONDS -lt 60 ]]; then
    log blue "${SECONDS}sec"
else
    log blue "$((SECONDS/60))min $((SECONDS%60))sec"
fi

rm -f "$tmp"
